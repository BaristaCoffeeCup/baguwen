## 322. 零钱兑换

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

来源：力扣（LeetCode）
链接：[https://leetcode.cn/problems/coin-change](https://leetcode.cn/problems/coin-change)
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 1. 物品的价值是哪一个属性

物品的价值是硬币组合的个数

## 2. 物品的重量是哪一个属性

物品的重量也是硬币的面额

## 3. 背包容量是哪一个属性

背包的最大容量是amount

## 4. 物品是只能取一次还是可以多次获取

物品可以多次获取



### 确定dp数组（dp table）以及下标的含义

```Java
使用一维数组
dp[i]为总金额为i的情况下，凑成i的最少硬币个数
```

### 确定递推公式

```Java
dp[j] = min(dp[j],dp[j - coins[i]] + 1);
```

### dp数组如何初始化

dp[0] = 0  凑成0元的最少硬币个数是0个

其他初始化为Integer.MAX_VALUE

### 确定遍历顺序

```Java
本题求解的是硬币的最少个数，因此无论是组合数还是排列数都可以
//先遍历物品
for(int i = 0;i < coins.length;i++){
  for(int j = coins[i];j <= amount;j++){
      if(dp[j - coins[i]] != Integer.MAX_VALUE){
          dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
      }
  }
}
```

### 举例推导dp数组



```Java
    public int coinChange(int[] coins, int amount) {
        int dp[] = new int[amount + 1];
        Arrays.fill(dp,Integer.MAX_VALUE);

        dp[0] = 0;

        //先遍历物品
        for(int i = 0;i < coins.length;i++){
            for(int j = coins[i];j <= amount;j++){
                if(dp[j - coins[i]] != Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }

        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
```