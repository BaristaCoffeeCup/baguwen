## 474. 一和零
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。



示例 1：

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

来源：力扣（LeetCode）
链接：[https://leetcode.cn/problems/ones-and-zeroes](https://leetcode.cn/problems/ones-and-zeroes)



## 1. 物品的价值是哪一个属性

目标是子集尽可能大，所以每一个字符串的价值均为1，仅用作计数

## 2. 物品的重量是哪一个属性

本题有两个重量维度，单个字符串的0的个数和1的个数

## 3. 背包容量是哪一个属性

背包容量有两个维度，一个是0的个数上限，一个是1的个数上限

## 4. 物品是只能取一次还是可以多次获取

每个物品仅取一次



### 确定dp数组（dp table）以及下标的含义

因为有两个维度的背包容量限制，所以使用二位数组

dp[i][j]表示在0的容量为i，1的容量为j的情况下，子集的最大长度

### 确定递推公式

针对当前遍历到的字符串，首先确认0的个数为numOfZero，1的个数为numOfOne

则dp[i][j]可以是由容量为i-numOfZero j-numOfOne时，子集长度 + 1

```Java
dp[i][j] = max(dp[i][j], dp[i-numOfZero][j-numOfOne] + 1);
```

本质上是两个01背包问题，两个一维dp组合在一起

### dp数组如何初始化

01背包均初始化为0

### 确定遍历顺序

```Java
// 先遍历每个字符串
for(int k = 0;k < strs.length;k++){
    // 计算当前字符串 0的个数和1的个数
    int numOfZero = 0;
    int numOfOne = 0;
    for(int l = 0;l < strs[k].lenght;l++){
      if(strs[k].charAt(l) == '0'){
          numOfZero++;
      }
      else{
          numOfOne++;
      }
    }
    
    // 先遍历0的容量
    for(int i = m;i >= numofZero;i--){
        // 再遍历1的容量
        for(int j = n;j >= numOfOne;j--){
            dp[i][j] = Math.max(dp[i][j], dp[i-numOfZero][j-numOfOne] + 1);
        }
    }
}
```

### 举例推导dp数组

```Java
    public int findMaxForm(String[] strs, int m, int n) {

        int dp[][] = new int[m+1][n+1];

        // 先遍历每个字符串
        for(int k = 0;k < strs.length;k++){
            // 计算当前字符串 0的个数和1的个数
            int numOfZero = 0;
            int numOfOne = 0;
            for(int l = 0;l < strs[k].length();l++){
            if(strs[k].charAt(l) == '0'){
                numOfZero++;
            }
            else{
                numOfOne++;
            }
            }
            
            // 先遍历0的容量
            for(int i = m;i >= numOfZero;i--){
                // 再遍历1的容量
                for(int j = n;j >= numOfOne;j--){
                    dp[i][j] = Math.max(dp[i][j], dp[i-numOfZero][j-numOfOne] + 1);
                }
            }
        }

        return dp[m][n];
    }
```