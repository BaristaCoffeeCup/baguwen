## 1143. 最长公共子序列
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

来源：力扣（LeetCode）
链接：[https://leetcode.cn/problems/longest-common-subsequence](https://leetcode.cn/problems/longest-common-subsequence)
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



### 确定dp数组（dp table）以及下标的含义

```Java
使用二维数组dp[i][j]
dp[i][j]表示数组A的0-i-1的部分和数组B的0-j-1的部分，两部分中最长公共子序列的长度
```

### 确定递推公式

```Java
如果A[i-1] == B[j-1]
则 dp[i][j] = dp[i-1][j-1] + 1;
如果不相同
则 dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
```

### dp数组如何初始化

```Java
dp[i][0] = 0;
dp[0][j] = 0;
```

### 确定遍历顺序

```Java
for(int i = 1;i <= text1.length();i++){
    for(int j = 1;j <= text2.length();j++){
        if(text1.charAt(i-1) == text2.charAt(j-1)){
            dp[i][j] = dp[i-1][j-1] + 1;
        }
        else{
            dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]);
        }
    }
}
```

### 举例推导dp数组



```Java
    public int longestCommonSubsequence(String text1, String text2) {
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];
        int result = 0;

        for(int i = 1;i <= text1.length();i++){
            for(int j = 1;j <= text2.length();j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else{
                    dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]);
                }
                result = Math.max(result, dp[i][j]);
            }
        }

        return result;
    }
```