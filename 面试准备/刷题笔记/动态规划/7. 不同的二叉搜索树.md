## 96. 不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

![](https://secure2.wostatic.cn/static/hLqz1WVpdVDwxJont1jRBV/image.png?auth_key=1689659384-nxETQkfviiVuCJUC764AJ2-0-e115933db601e1cc2e232ac19059aefe)

**输入：** n = 3
**输出：** 5

[https://leetcode.cn/problems/unique-binary-search-trees/submissions/](https://leetcode.cn/problems/unique-binary-search-trees/submissions/)



### 确定dp数组（dp table）以及下标的含义

使用一维数组，dp[i]表示i个节点能够组成的互不相同的二叉搜索树的个数

### 确定递推公式

1-n 依次作为根节点，则以i为根节点构建的二叉搜索树的个数取决于根节点两侧的节点能够构建出的搜索树的个数

也就是 dp[i] 的大小取决于以 1到i中，每个数依次作为根节点时，左右子树的二叉搜索树总和的乘积

dp[i] += dp[i-j] * dp[j-1]，其中1 ≤ j ≤ i

### dp数组如何初始化

dp[0] = 1

### 确定遍历顺序

双重循环遍历

外层循环 1 ≤ i ≤ n，依次计算i个节点能够构建出的二叉搜索树的总个数

内层循环 1 ≤ j ≤ i，依次累加 以 j 为根节点时，所能构建出的二叉搜索树的个数

### 举例推导dp数组





```Java
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;

        for(int i = 1;i <= n;i++){
            for(int j = 1;j <= i;j++){
                dp[i] += dp[i-j] * dp[j-1];
            }
        }

        return dp[n];
    }
```

