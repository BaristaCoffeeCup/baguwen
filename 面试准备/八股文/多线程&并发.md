## 实现多线程的方法
__1. 继承Thread类__
Thread类本身是实现Runnable接口的一个实例类，继承Thread类，重写run方法，并调用start方法启用一个新线程，并执行run()方法内部的逻辑，即可实现多线程能力。

```Java
public class MyThread extends Thread {
    public void run() {
        System.out.println("MyThread.run()");
    }
}
MyThread myThread1 = new MyThread();
myThread1.start();
```

__2. 实现Runnable接口__
定义一个实现了Runnable接口的类`MyRunnable`，并在类中实现run()接口方法，将`MuRunnable`的实例化对象作为参数传入一个`Thread`实例中，调用Thread实例的start()接口启动新线程。

``` Java
public class MyRunnable implements Runnable {
    public void run() {
        // 要执行的代码
    }
}
MyRunnable myRunnable = new MyRunnable();
Thread thread = new Thread(myRunnable);
thread.start();
```

__3. 使用Callable和Future接口__
- 定义一个实现了Callable接口的类`MuCallable`，并实现call()接口，该接口具备返回值并且可以抛出异常。
- 将该Callable任务提交到`ExecutorService`后，可以获得一个`Future`对象，这个对象代表着任务的生命周期，并且提供了一些方法来检查任务是否已经完成，取消任务，或者在任务完成后获取结果。在任务完成前，调用`get()`方法将会阻塞当前线程，直到结果可用。
  
```Java
public class NameCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        String name = "John Doe";
        return name;
    }
}

public class FutureExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Callable<String> callable = new NameCallable();
        Future<String> future = executor.submit(callable);
        String result = future.get();
        System.out.println(result);
        executor.shutdown();
    }
}
```

__4. 基于线程池的形式__
使用线程池管理线程的创建，任务分发，线程回收等生命周期的管理，可以极大减少因为线程创建销毁产生的资源消耗。
- **FixedThreadPool**：固定大小线程池。该线程池一旦被创建，其中包含的线程数就不会改变。如果所有线程都处于活动状态并且又有新的任务提交，那么这些任务就会在队列中等待，直到有线程可用为止。
- **CachedThreadPool**：缓存线程池。该线程池可以根据需要创建新线程，但在先前构造的线程可用时将重用它们；会清理缓存中长时间没有被调用的线程。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。
- **ScheduledThreadPool**：计划线程池。该线程池支持延迟执行或定时执行某个任务。例如，可以安排一个任务在5分钟后执行，或者每隔1秒执行一次。
- **SingleThreadExecutor**：单线程池。该线程池只包含一个线程，因此所有任务都是按顺序执行的。如果该线程因异常退出而结束，那么会创建一个新线程来替代它。

<br></br>

## submit()和execute()两种方法的区别
- **返回值类型不同**：execute()方法定义在Executor接口里，返回值类型为void；submit()对象的返回值是Future对象，定义在ExecutorService中
- **接受类型不同**：execute()方法仅接收Runnable类型的对象，而submit()可以接口Runnable和Callable类型的入参
- **异常抛出方式不同**：使用execute()提交任务时，如果出现异常会直接抛出；使用submit()提交任务时，如果出现异常不会直接抛出，而是等submit()返回的Future对象的get()方法被调用时，才会抛出异常

<br></br>

## 线程的生命周期
- **新建（NEW）**：线程刚被创建时处于的状态，已被分配了必须的内存资源，但是还没有启动。
- **就绪（RUNNABLE）**：当线程对象被调用start()方法时，JVM为其创建了方法调用栈和程序计数器，进入就绪状态，等待CPU调度执行。
- **运行（RUNNING）**：处于就绪状态的线程对象被调用run()方法，并获取CPU资源，可以运行run()方法内部的代码块，进入运行状态。
- **阻塞（BLOCKED）**：当线程因为某些原因让出CPU时间片，暂停运行，则进入的阻塞状态
  - 等待阻塞（Waiting）：当一个线程调用了`Object.wait()`、`Thread.join()`或`LockSupport.park()`方法时，它会进入等待阻塞状态。此时，它会释放占用的锁资源，并等待其他线程发出通知或中断。
  - 同步阻塞（Blocked）：当一个线程试图获取一个已经被其他线程占用的锁时，它会进入同步阻塞状态。此时，它会等待其他线程释放锁资源。
  - 其他阻塞（Sleeping）：当一个线程调用了`Thread.sleep()`方法时，它会进入其他阻塞状态。此时，它不会释放占用的锁资源，并等待指定时间后自动恢复。
- **死亡（TERMINATED）**：线程结束，释放内存资源，进入死亡状态
  - 等待线程的run方法执行完毕，正常结束线程
  - 使用interrupt方法终止线程
  - 使用stop方法强行终止线程

<br></br>

## notify()和notifyAll()有什么区别
- notify()方法随机唤醒对象的等待池中的一个线程，进入锁池；notifyAll()唤醒对象的等待池中的所有线程，进入锁池。
- 等待池是指调用了对象的wait()方法而释放锁的线程所在的队列，它们不会去竞争对象的锁；锁池是指等待获取对象锁的线程所在的队列，它们会去竞争对象的锁。
- 被唤醒的线程并不会立即执行，而是要等待获取对象锁后才能继续执行。如果使用notify()方法，只有一个线程会由等待池进入锁池，而其他线程仍然在等待被唤醒；如果使用notifyAll()方法，所有线程都会由等待池进入锁池，然后参与锁的竞争。
- 使用notify()方法可能会导致死锁，因为有可能唤醒的线程并不是能够继续执行的线程，而其他能够继续执行的线程却一直在等待；使用notifyAll()方法可以避免死锁，因为它会让所有线程都有机会获取对象锁。

<br></br>

## sleep()和wait() 有什么区别?
- **所属类不同：**`sleep()`是Thread类的本地方法，而`wait()`是Object对象的本地方法。
- **使用范围不同：**`sleep()`可以用在程序的任意位置，而`wait()`只能用在同步方法或者同步代码块中。
- **释放锁的状态不同：**`sleep()`方法不会释放当前线程持有的对象锁，而`wait()`方法会试放当前线程持有的对象锁，并进入等待池。
- **唤醒方式不同：**`sleep()`方法执行需要传入参数指定线程休眠时长，即必须指定休眠时长，超时时间过了后，则自动唤醒；`wait()`方法执行可以不传参，不传参代表永久休眠，但是需要其他线程执行notify()或notifyAll()方法才可以被唤醒。
- **使用场景不同：**`sleep()`方法用于当前线程休眠，而`wait()`方法用于线程之间的通信。


<br></br>

## 如何理解volatile关键字？
- volatile保证了可见性:即被volatile关键字修饰的变量，其发生变化时，会立刻被写回主存，其他所有线程都会知道该变量的变化；程序每次读取或修改该变量时，都会强制从主存中获取该变量的实际值，而不会优化内存读取，从线程本地内存中读取
- volatile禁止指令重排序，保证了部分程序的部分有序；可以保证程序执行到被修饰的变量的读写操作时，其之前的指令全部被执行，其变量的变化对后面的指令可见，其之后的指令全部没有执行；但是不能保证该指令前后的指令有序性。
- volatile关键字不能保证原子性。原子性是指一个操作不可拆分，全部执行成功或全部执行失败；因为volatile不会造成线程阻塞，所以一个被该关键字修饰的变量或者对象，可能会被多个线程访问或修改，所以无法保证原子性


<br></br>


## 如何理解Synchronized关键字？
- Synchronized关键字可以保证原子性，可见性和有序性
  - 原子性：当一个线程进入由`synchronized`修饰的方法或代码块时，该线程会获取到一个锁，只有当该线程释放锁后，其他线程才能进入该方法或代码块，保证了同一时间只有一个线程可以执行该方法或代码块，保证了原子性
  - 可见性：当一个线程进入一个`synchronized`方法或代码块时，它会清空线程本地内存中的共享变量的值，然后从主内存中重新读取最新的值。当该线程退出该方法或代码块时，它会把本地内存中的共享变量的值刷新到主内存中。这样就保证了一个线程对共享变量的修改能够被其他线程立即看到，从而保证了可见性。
  - 有序性：`synchronized`不允许指令重排序，但是可以保证同一时间只有一个线程进入被修饰的代码块或方法，所有操作都是按照代码顺序进行的，从而保证了有序性
- Synchronized关键字可以修饰实例方法，静态方法和代码块
  - 修饰实例方法：锁定当前对象实例，线程进入实例方法需要先获取当前对象实例的锁
  - 修饰静态方法：给当前类加锁，会影响到该类的所有实例对象，因为静态成员不属于任何一个实例对象；当多个线程同时访问该类的静态方法时，会出现阻塞现象；当线程A访问该类的静态方法，而线程B访问该类的某个实例对象的非静态方法，则不会发生互斥现象。**访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态synchronized 方法占用的锁是当前实例对象锁。**
  - 修饰代码块：锁定的是括号里配置的对象，如果多个线程同时访问同一个对象的synchronized代码块，那么这些线程将会被阻塞


<br></br>


## volatile和synchronized区别
- `作用范围不同`：volatile用于修饰变量，synchronized用于修饰一段代码或者一个方法
- `是否可以保证原子性`：volatile不能保证原子性，而synchronized可以同时保证原子性，可见性和有序性
- `性能区别`：多线程访问被volatile修饰的变量时不会被阻塞，而访问被synchronized修饰的代码块或方法时，可能会发生线程阻塞
- `实现有序性的方式不同`：volatile通过禁止指令重排序及在指令之间插入内存屏障指令来实现有序性；而synchronized不禁止重排序，而是单纯的避免了多线程仿真同一资源的场景。


<br></br>

## 为什么wait和notify方法要在同步块中调用？
- 在 Java 中，同步方法或同步块可以保证多个线程访问共享资源时的互斥性，即同一时间只有一个线程可以访问共享资源
- 调用目标对象的wait()之前，必须要保证当前线程拥有对象锁，才可以实现强制释放对象锁的能力
- 调用目标对象的notify()或notifyAll()之前，也必须保证当前线程可以获取到对象锁
- 上述两种情况都要求当前线程处于同步代码或同步块中，以保证共享资源的访问互斥性以及数据的一致性


<br></br>


## SynchronizedMap和ConcurrentHashMap有什么区别？
- 两种Map都是线程安全的
- SynchronizedMap类似于HashTable，在线程调用SynchronizedMap的成员方法时，会对整个Map进行同步，同一时刻只能有一个线程操作Map内的数据
- ConcurrentHashMap采用了分段锁，对Map中的所有`桶`加了锁，当某一线程访问其中一个桶时，该线程仅获取这一个桶的锁，其他线程仍然可以继续操作其他桶
- 两者比较下，安全性和性能都是ConcurrentHashMap更好


<br></br>


## 







