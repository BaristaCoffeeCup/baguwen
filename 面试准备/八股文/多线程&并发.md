## 实现多线程的方法
__1. 继承Thread类__
Thread类本身是实现Runnable接口的一个实例类，继承Thread类，重写run方法，并调用start方法启用一个新线程，并执行run()方法内部的逻辑，即可实现多线程能力。

```Java
public class MyThread extends Thread {
    public void run() {
        System.out.println("MyThread.run()");
    }
}
MyThread myThread1 = new MyThread();
myThread1.start();
```

__2. 实现Runnable接口__
定义一个实现了Runnable接口的类`MyRunnable`，并在类中实现run()接口方法，将`MuRunnable`的实例化对象作为参数传入一个`Thread`实例中，调用Thread实例的start()接口启动新线程。

``` Java
public class MyRunnable implements Runnable {
    public void run() {
        // 要执行的代码
    }
}
MyRunnable myRunnable = new MyRunnable();
Thread thread = new Thread(myRunnable);
thread.start();
```

__3. 使用Callable和Future接口__
- 定义一个实现了Callable接口的类`MuCallable`，并实现call()接口，该接口具备返回值并且可以抛出异常。
- 将该Callable任务提交到`ExecutorService`后，可以获得一个`Future`对象，这个对象代表着任务的生命周期，并且提供了一些方法来检查任务是否已经完成，取消任务，或者在任务完成后获取结果。在任务完成前，调用`get()`方法将会阻塞当前线程，直到结果可用。
  
```Java
public class NameCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        String name = "John Doe";
        return name;
    }
}

public class FutureExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Callable<String> callable = new NameCallable();
        Future<String> future = executor.submit(callable);
        String result = future.get();
        System.out.println(result);
        executor.shutdown();
    }
}
```

__4. 基于线程池的形式__
使用线程池管理线程的创建，任务分发，线程回收等生命周期的管理，可以极大减少因为线程创建销毁产生的资源消耗。
- **FixedThreadPool**：固定大小线程池。该线程池一旦被创建，其中包含的线程数就不会改变。如果所有线程都处于活动状态并且又有新的任务提交，那么这些任务就会在队列中等待，直到有线程可用为止。
- **CachedThreadPool**：缓存线程池。该线程池可以根据需要创建新线程，但在先前构造的线程可用时将重用它们；会清理缓存中长时间没有被调用的线程。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。
- **ScheduledThreadPool**：计划线程池。该线程池支持延迟执行或定时执行某个任务。例如，可以安排一个任务在5分钟后执行，或者每隔1秒执行一次。
- **SingleThreadExecutor**：单线程池。该线程池只包含一个线程，因此所有任务都是按顺序执行的。如果该线程因异常退出而结束，那么会创建一个新线程来替代它。

<br></br>

## 如何停止一个线程
- 等待线程的run方法执行完毕，正常结束线程
- 使用interrupt方法终止线程
- 使用stop方法强行终止线程

<br></br>

## notify()和notifyAll()有什么区别
- notify()方法随机唤醒对象的等待池中的一个线程，进入锁池；notifyAll()唤醒对象的等待池中的所有线程，进入锁池。
- 等待池是指调用了对象的wait()方法而释放锁的线程所在的队列，它们不会去竞争对象的锁；锁池是指等待获取对象锁的线程所在的队列，它们会去竞争对象的锁。
- 被唤醒的线程并不会立即执行，而是要等待获取对象锁后才能继续执行。如果使用notify()方法，只有一个线程会由等待池进入锁池，而其他线程仍然在等待被唤醒；如果使用notifyAll()方法，所有线程都会由等待池进入锁池，然后参与锁的竞争。
- 使用notify()方法可能会导致死锁，因为有可能唤醒的线程并不是能够继续执行的线程，而其他能够继续执行的线程却一直在等待；使用notifyAll()方法可以避免死锁，因为它会让所有线程都有机会获取对象锁。

<br></br>

## sleep()和wait() 有什么区别?
- **所属类不同：**`sleep()`是Thread类的本地方法，而`wait()`是Object对象的本地方法。
- **使用范围不同：**`sleep()`可以用在程序的任意位置，而`wait()`只能用在同步方法或者同步代码块中。
- **释放锁的状态不同：**`sleep()`方法不会释放当前线程持有的对象锁，而`wait()`方法会试放当前线程持有的对象锁，并进入等待池。
- **唤醒方式不同：**`sleep()`方法执行需要传入参数指定线程休眠时长，即必须指定休眠时长，超时时间过了后，则自动唤醒；`wait()`方法执行可以不传参，不传参代表永久休眠，但是需要其他线程执行notify()或notifyAll()方法才可以被唤醒。
- **使用场景不同：**`sleep()`方法用于当前线程休眠，而`wait()`方法用于线程之间的通信。


<br></br>

## 如何理解volatile关键字？
- volatile是类修饰符，被该关键字修饰的变量或者对象，可能会被多个线程访问或修改；因此编译后的程序每次读取或修改该变量时，都会直接仿真该变量的内存地址，而不会优化内存读取，从寄存器中读取暂存的值。
- volatile保证了可见性，即被volatile关键字修饰的变量，其发生变化时，其他所有线程都会知道该变量的变化。
- volatile禁止指令重排序，保证了部分程序的部分有序；可以保证程序执行到被修饰的变量的读写操作时，其之前的指令全部被执行，其变量的变化对后面的指令可见，其之后的指令全部没有执行；但是不能保证该指令前后的指令有序性。