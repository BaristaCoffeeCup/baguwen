## 实现多线程的方法
__1. 继承Thread类__
Thread类本身是实现Runnable接口的一个实例类，继承Thread类，重写run方法，并调用start方法启用一个新线程，并执行run()方法内部的逻辑，即可实现多线程能力。

```Java
public class MyThread extends Thread {
    public void run() {
        System.out.println("MyThread.run()");
    }
}
MyThread myThread1 = new MyThread();
myThread1.start();
```

__2. 实现Runnable接口__
定义一个实现了Runnable接口的类`MyRunnable`，并在类中实现run()接口方法，将`MuRunnable`的实例化对象作为参数传入一个`Thread`实例中，调用Thread实例的start()接口启动新线程。

``` Java
public class MyRunnable implements Runnable {
    public void run() {
        // 要执行的代码
    }
}
MyRunnable myRunnable = new MyRunnable();
Thread thread = new Thread(myRunnable);
thread.start();
```

__3. 使用Callable和Future接口__
- 定义一个实现了Callable接口的类`MuCallable`，并实现call()接口，该接口具备返回值并且可以抛出异常。
- 将该Callable任务提交到`ExecutorService`后，可以获得一个`Future`对象，这个对象代表着任务的生命周期，并且提供了一些方法来检查任务是否已经完成，取消任务，或者在任务完成后获取结果。在任务完成前，调用`get()`方法将会阻塞当前线程，直到结果可用。
  
```Java
public class NameCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        String name = "John Doe";
        return name;
    }
}

public class FutureExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Callable<String> callable = new NameCallable();
        Future<String> future = executor.submit(callable);
        String result = future.get();
        System.out.println(result);
        executor.shutdown();
    }
}
```

__4. 基于线程池的形式__
使用线程池管理线程的创建，任务分发，线程回收等生命周期的管理，可以极大减少因为线程创建销毁产生的资源消耗。
- **FixedThreadPool**：固定大小线程池。该线程池一旦被创建，其中包含的线程数就不会改变。如果所有线程都处于活动状态并且又有新的任务提交，那么这些任务就会在队列中等待，直到有线程可用为止。
- **CachedThreadPool**：缓存线程池。该线程池可以根据需要创建新线程，但在先前构造的线程可用时将重用它们；会清理缓存中长时间没有被调用的线程。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。
- **ScheduledThreadPool**：计划线程池。该线程池支持延迟执行或定时执行某个任务。例如，可以安排一个任务在5分钟后执行，或者每隔1秒执行一次。
- **SingleThreadExecutor**：单线程池。该线程池只包含一个线程，因此所有任务都是按顺序执行的。如果该线程因异常退出而结束，那么会创建一个新线程来替代它。

<br></br>

## 如何停止一个线程
- 等待线程的run方法执行完毕，正常结束线程
- 使用interrupt方法终止线程
- 使用stop方法强行终止线程

<br></br>

## notify()和notifyAll()有什么区别
- notify()方法随机唤醒对象的等待池中的一个线程，进入锁池；notifyAll()唤醒对象的等待池中的所有线程，进入锁池。
- 等待池是指调用了对象的wait()方法而释放锁的线程所在的队列，它们不会去竞争对象的锁；锁池是指等待获取对象锁的线程所在的队列，它们会去竞争对象的锁。
- 被唤醒的线程并不会立即执行，而是要等待获取对象锁后才能继续执行。如果使用notify()方法，只有一个线程会由等待池进入锁池，而其他线程仍然在等待被唤醒；如果使用notifyAll()方法，所有线程都会由等待池进入锁池，然后参与锁的竞争。
- 使用notify()方法可能会导致死锁，因为有可能唤醒的线程并不是能够继续执行的线程，而其他能够继续执行的线程却一直在等待；使用notifyAll()方法可以避免死锁，因为它会让所有线程都有机会获取对象锁。