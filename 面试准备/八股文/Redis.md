![Redis知识体系](../八股文/图例/Redis知识体系.png)

## 什么是Redis
Redis是一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统）

<br>

## Redis的优势
- 高性能：Redis完全基于内存操作，因此具有非常高的读写速度。相比传统的磁盘数据库，Redis可以实现更低的延迟和更高的吞吐量。

- 数据结构丰富：Redis支持多种数据结构，包括字符串、列表、哈希表、集合、有序集合等。这些数据结构使得开发人员可以更方便地处理复杂的数据需求，并在内存中进行高效的操作。

- 持久化支持：Redis提供了两种持久化机制，即快照（snapshotting）和日志（append-only file）。这样可以确保即使在服务器重启或崩溃时，数据也能够安全地保存。

- 高可用性：Redis支持主从复制和sentinel机制，可以实现数据的自动备份和故障恢复。当主节点发生故障时，Redis可以自动将一个从节点晋升为新的主节点，从而保证系统的高可用性。

- 发布/订阅功能：Redis提供了发布/订阅模式，允许开发人员在应用程序之间进行实时消息传递。这对于构建实时通信、消息队列和事件驱动的应用程序非常有用。

- 缓存功能：由于Redis具有高性能和丰富的数据结构，它被广泛用作缓存层。通过将常用的数据存储在Redis中，可以显著提高应用程序的响应速度和吞吐量。

- 存储容量：单个字符串最大存储容量为512MB

<br>

## Redis的数据结构
### 5种基础数据结构
![Redis基础数据类型](../八股文/图例/Redis基础数据类型.png)
### 3种特殊数据结构
- HyperLogLogs（基数统计）
- Bitmap （位存储）
- geospatial (地理位置)

<br>

## Redis线程模型


<br>

## 单线程的Redis为什么快
- 纯内存操作
- 单线程操作，避免了频繁的上下文切换
- 采用了非阻塞I/O多路复用机制

<br>


## 持久化
### 为什么需要持久化
Redis的存储是基于内存的，一旦运行Redis的机器宕机，就会造成数据缺失，只能从后端数据库进行数据恢复，而后端数据库存在性能瓶颈，在面对大数据场景下会导致服务响应问题，因此需要Redis持久化.
### RDB持久化方式
- 原理：使用快照的形式半持久化记录Redis中的所有键值对信息，主线程fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化结束后替换上一次的快照文件，存入磁盘内
- 优点：
  - 容灾性好：全局只有一个持久化文件，方便压缩并转移到其他存储介质上，二进制的数据，占用内存更小，更紧凑，更适合做为备份文件
  - 性能最大化：fork子进程进行持久化，不会阻塞主进程的任务，IO最大化
  - 重启效率更高：与AOF格式文件相比，RDB文件的重启效率更高
- 缺点：
  - RDB是周期性持久化方式，如果最后一次RDB持久化后Redis崩溃，则崩溃之后产生的数据都会丢失
  - RDB通过fork子进程进行持久化，系统开销较大，如果数据集较大同时会导致fork操作时间过长
### AOF持久化方式
- 原理：
  - Redis服务器将每个写操作以协议格式追加到AOF文件中。
  - AOF文件保存了完整的Redis操作日志，以文本形式记录了所有对Redis的写操作。
  - 当Redis重新启动时，它会通过重新执行AOF文件中保存的所有写操作来恢复数据。
- 优点：
  - 持久化：AOF提供了持久化存储机制，确保数据在服务器重启后不会丢失。
  - 可读性：AOF文件保存了Redis操作的完整日志，易于阅读和分析。
  - 安全性：AOF采用追加方式记录写操作，不会覆盖之前的数据，因此可以保护数据免受意外的损坏或数据丢失。
- 缺点：
  - 文件大小：由于AOF文件记录了所有写操作，随着时间的推移，文件的大小会不断增长，可能导致占用大量磁盘空间。
  - 写性能：相比于快照持久化方式，AOF的写入性能通常较差，因为需要频繁地将写操作追加到文件末尾。
  - 恢复时间：当AOF文件过大时，Redis重新启动时需要执行的写操作较多，可能导致恢复时间较长。
> 混合使用 AOF 日志和内存快照的方法：内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。


<br>


## 发布订阅模式
Redis发布订阅使用了发布/订阅模型。当有新消息发布到频道时，Redis会将该消息发送给所有订阅了该频道的客户端。
Redis的发布订阅机制是一种无保证的消息传递方式。也就是说，当有新消息发布时，Redis会尽最大努力将消息发送给订阅者，但在某些情况下（例如网络故障），消息可能会丢失。

<br>


## 过期键删除策略
- 定时删除:在设置键的过期时间的同时，创建一个定时器， 让定时器在键的过期时间来临时，立即执行对键的删除操作。
- 惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
- 定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。


<br>


## 内存淘汰算法
- Noeviction（不淘汰）：这是默认的淘汰策略，当内存不足以容纳新数据时，写操作会报错，指示内存溢出。
- Allkeys-lru（最近最少使用）：在所有键中，LRU算法选择最近最少被访问的键，并删除它们。这是最常用的淘汰策略。
- Volatile-lru（带过期时间键的最近最少使用）：只对设置了过期时间的键进行LRU淘汰。
- Allkeys-random（随机删除）：在所有键中，随机选择一些键进行删除。
- Volatile-random（带过期时间键的随机删除）：只对设置了过期时间的键进行随机删除。
- Volatile-ttl（带过期时间键的TTL淘汰）：根据键的剩余生存时间（TTL）进行淘汰，较早过期的键优先删除。


<br>


## Redis事务
redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令；
基本思想是将一系列的命令打包成一个单独的操作单元，然后一次性地将这个操作单元提交给服务器执行。在事务执行期间，服务器会按照顺序执行事务中的各个命令，并在事务执行完成后返回结果。<br>

Redis事务使用下列指令：
- MULTI ：开启事务，redis会将后续的命令逐个放入队列中
- EXEC：执行事务中的所有操作命令
- DISCARD：取消事务，放弃执行事务块中的所有命令
- WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。
- UNWATCH：取消WATCH对所有key的监视。


<br>

## Redis事件
### 有哪些事件类型？
- 可读事件（Read Event）：当一个文件描述符可读时触发。
- 可写事件（Write Event）：当一个文件描述符可写时触发。
- 时间事件（Time Event）：基于时间触发的事件，用于执行定时任务。
- 连接事件（Connection Event）：当有新的客户端连接或断开连接时触发。
### 


<br>


## 主从复制机制
### 全量复制阶段
主节点会执行一个保存操作，将当前数据库状态保存到磁盘上的RDB文件中，并将该文件发送给从节点。从节点接收到RDB文件后，会将其加载到自己的内存中，使得从节点的数据与主节点保持一致。
### 增量复制阶段
全量复制阶段之后，主节点会将自己执行的写操作以命令的形式发送给从节点。从节点接收到命令后，会按照相同的顺序执行这些命令，从而保持与主节点的数据一致性。主节点会周期性地将自己执行的写操作发送给从节点，以保证数据的实时同步。
> 在主从复制模型中，主节点负责接收客户端的写请求，并将写操作同步给所有的从节点。从节点只能接收客户端的读请求，不能直接处理写请求。这样的设计可以分担主节点的负载，同时实现数据冗余和高可用性。
需要注意的是，Redis的主从复制模型是异步的，即主节点将写操作发送给从节点后并不等待从节点的响应。因此，在某些情况下，主节点与从节点之间的数据可能出现短暂的不一致。但是，通过合理的配置和监控，可以保证数据的最终一致性。

<br>

## 哨兵机制
- 监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。
- 自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。
- 配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。
- 通知（Notification）：哨兵可以将故障转移的结果发送给客户端。


<br>


## Redis集群模式（分片机制）
Redis 集群架构是支持单节点单机模式的，也支持一主多从的主从结构，还支持带有哨兵的集群部署模式。
<br>Redis 集群并没有使用一致性 hash，而是引入了哈希槽的概念。Redis 集群有16384（2^14）个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分hash 槽。



## 缓存问题






