## MyBatis的优点
- 简单易用：基于SQL语句变成，解耦了程序代码和SQL语句，可通过XML灵活配置，并提供了动态SQL语句生成功能
- 方便集成：支持JDBC涉及的所有数据库，同时节省了JDBC配置驱动等开发量
- 性能优化：MyBatis通过提供缓存机制、延迟加载和批量操作等功能来优化性能。

<br>

## #{}和${}的区别是什么？
- `#{} `语法是更安全和推荐的参数占位符语法，会将参数值作为预编译的参数传递给数据库驱动程序, 可以防止 SQL 注入攻击，并处理特殊字符的转义。
- `${}` 语法是一种简单的字符串替换语法，会直接将参数值替换到 SQL 语句中，类似于字符串拼接,不提供安全保护，主要用于静态 SQL 片段的替换。

<br>

## 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？
- 可以使用 @Results 和 @Result 注解来进行映射配置。在 @Results 注解中，可以通过 @Result 注解指定属性名和字段名之间的映射关系。
- 在 XML 配置文件中，可以使用 resultMap 元素来定义属性名和字段名之间的映射关系。

<br>

## Mybatis是如何进行分页的？分页插件的原理是什么？
- 第一种，直接在 Select 语句上增加数据库提供的分页关键字，然后在应用程序里
面传递当前页，以及每页展示条数即可，比如limit，offset。
- 第二种，使用 Mybatis 提供的 RowBounds 对象，实现内存级别分页。
- 第三种，基于 Mybatis 里面的 Interceptor 拦截器，在 select 语句执行之前动态拼接分页关键字（分页插件PageHelper的原理）。

<br>

## MyBatis 实现一对一有几种方式?具体怎么操作的？
- 联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；
- 嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。

<br>

## Mybatis是否支持延迟加载？如果支持，它的实现原理是什么
1. Mybatis支持延迟加载； 延迟加载是指在需要访问关联对象时才进行加载，而不是在查询主对象时立即加载关联对象。
2. 通过代理对象和动态代理的方式实现的。当查询主对象时，Mybatis会返回一个代理对象，而不是真正的关联对象。当访问代理对象的关联属性时，Mybatis会拦截这个访问并触发延迟加载。


<br>


## 说一说MyBatis的缓存机制
### 一级缓存（Local Cache）：

- 一级缓存是MyBatis默认开启的缓存机制，它是在SqlSession级别的缓存。
当执行查询语句时，查询的结果会被缓存到SqlSession的缓存中，默认情况下，缓存是开启的。
- 一级缓存的作用范围是在同一个SqlSession中，因此对于同一个SqlSession执行的相同查询语句，只会查询一次数据库，后续的查询会直接从缓存中获取结果。
- 一级缓存在SqlSession关闭之前都有效，如果在同一个SqlSession中执行了增删改操作，则会清空缓存。

### 二级缓存（Second Level Cache）：

- 二级缓存是在Mapper级别的缓存，它可以被多个SqlSession共享。
- 二级缓存需要手动配置开启，在Mapper XML文件中添加配置项。
- 当执行查询语句时，查询的结果会被缓存到二级缓存中，如果其他SqlSession执行相同的查询语句，会从二级缓存中获取结果，而不会再次查询数据库。
- 二级缓存默认是关闭的，需要手动配置开启，并且需要注意的是，二级缓存的有效范围是在同一个Mapper中。












