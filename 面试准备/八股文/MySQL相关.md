## MySQL的三大范式
- 第一范式（1NF）：数据表中的每一列都是原子性的，即不可再分。每个数据表必须有一个主键，用于唯一标识每一条记录。

- 第二范式（2NF）：在满足1NF的基础上，数据表中的非主键列必须完全依赖于主键，而不能依赖于主键的一部分。即每个非主键列必须与主键形成完整的依赖关系。

- 第三范式（3NF）：在满足2NF的基础上，数据表中的非主键列之间不能存在传递依赖关系。即非主键列之间不能相互依赖，而是通过主键进行关联。

<br>

## 事务的特性
- A：原子性：一个事务要不执行成功，要不执行失败
  - 由undo log保证，记录了所有需要回滚的日志信息，事务回滚时可以撤销已经执行的sql
- I：隔离性：事务在没有提交之前，其对数据的修改对于其他事务是不可见的
  - 由MVCC保证，在MVCC（多版本并发控制）中，每个事务在读取和修改时，根据事务开始的时间戳（也称为版本号）来确定所读取的数据版本。每个数据行都可以有多个版本，每个版本都有一个唯一的时间戳，用于标识该版本的创建时间。
- C：一致性：事务的提交总会让数据库的从一个一致性状态转移到另一个一致性状态
  - 一般由代码层面保证
- D：持久性：一个事务一旦提交，其产生的变化就会永远存储在数据库内
  - 由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作

<br>

## 多并发场景下，一致性问题
- 修改丢失：事务A对数据进行修改并提交后，事务B对同一条数据进行了修改，覆盖了事务A的结果
- 脏读：事务A对数据进行了修改但没有提交，并进行了回滚，回滚之前事务B读取了数据，与真实数据存在差异
- 不可重复读：事务A读取了一条数据，事务B对同一条数据进行了修改，事务A再次读取该条数据发现数据发生了变化，与第一次读取的结果不一样
- 幻读：事务A按照某组条件读取了一组数据，事务B按照同等条件新增或删除了数据，导致事务A再次读取数据时，数据的条数发生了变化

<br>

## 事务的隔离级别
|隔离级别 | 原理 | 脏读 | 不可重复读 | 幻读 |
|:---:|:---:|:---:|:---:|:---:|
| 未提交可读 | 一个事务中的修改，没有提交之前对于其他事务来说也是可见的 | √ | √ | √ | 
| 已提交可读 | 一个事务的修改，只有提交之后对其他事务才是可见的 | × | √ | √（在提交可读的事务隔离级别下，事务只在读取数据时对数据行进行锁定，而不会对所读取的整个数据集进行锁定。这导致了在读取期间可能发生数据的插入或删除，从而造成了幻读。） | 
| 可重复读 | 保证同一个事务多次读取同样数据的结果是一样的 | × | × | √ |
| 可串行化 | 强制事务串行化执行 | × | × | × |

<br>

## SQL中有哪几类日志？
undo log 记录的是数据操作前的样子

redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）

bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）

<br>

## 从准备更新一条数据到事务提交的全流程
1. 执行器根据MySQL的查询计划查询数据，优先从缓存池中查询数据，没有查到再从数据库中查询数据，查询到后更新到缓存池（BufferPool）中
2. 数据被加载到BufferPool的同时，将更新之前的SQL语句写入undo log，用于后期回滚
3. update操作是在BufferPool中执行的，数据更新的同时会同步加载到redo log buffer内
4. 完成之后进行事务提交
   - 将redo log buffer中的数据写入redo log
   - 将本次的数据操作记录到bin log内
   - 将bin log的文件名称和更新内容在bin log中的位置信息同步写入redo log中，最后添加commit标记

<br>

## MySQL的索引有哪些？
- B+ Tree索引：可以保证数据的有序性，支持精确查找和范围查找
- 哈希索引：使用哈希函数将索引列的值计算为哈希码，并将哈希码存储在索引中，适用于精确查找，但是不支持范围查找和排序
- 全文索引：用于全文搜索，它能够在文本数据中进行关键字搜索
- 空间数据索引：对包含空间数据（如地理位置坐标）的列进行搜索。空间索引可以用于空间关系查询

<br>

## B树和B+树
### B树（假设为m阶）
- 根节点的关键字个数是1到m-1个，至少有两个子节点
- 每个中间节点均保存k-1个元素和k个孩子，m/2 <= k <= m
- 每个叶子节点都包含k-1个元素
- 每个节点内部的关键字按照从小到大排列，左子树的数据都比当前节点小，右子树的数据都比当前节点大
- 所以叶子节点都在一层
- B树的每个节点都会存储索引和数据
- 时间复杂度最好是O(1),最坏是Olog(n)

### B+树
- 根节点的关键字个数是1到m-1个，非根节点的关键字个数是m/2 到 m-1个
- 节点分为两类，索引节点和叶子节点；索引节点只存储索引，不存储数据；数据都存储在叶子节点上
- 索引节点中索引key比左子树的所有key大，比右子树的所有key小；节点内部key按照从小到大的次序进行排列
- 叶子节点除了存储数据，还会存储指向相邻节点的指针，按照key的大小形成一个有序单向链表
- 每一个父节点的索引都会出现在子节点中，是最小或最大的索引；根节点是所有节点中最大的索引
- 时间复杂度稳定在OLog(n)

### B树和B+树的区别
- IO次数更少：B+树的索引节点不不含实际数据，所以相同大小的磁盘页可以存储更多的索引节点
- 查询性能稳定：每一次数据查询最终都要查询到叶子节点
- 范围查询更加方便：先二分查找到范围的左值，再遍历叶子节点链表即可

### 根据数据量估算B+树的树高
假设数据量为N，每个节点有B个索引，那么树的高度= log2(N) / log2(B)

<br>

## 什么是聚簇索引和非聚簇索引？
聚簇索引的叶子节点保存真实的数据，而非聚簇索引的叶子节点的数据区保存的是聚簇索引的关键字的值
- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
- 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行
>如果和MyISAM一样在主键索引和辅助索引的叶子节点中都存放数据行指针，一旦数据发生迁移，则需要去重新组织维护所有的索引。

<br>

## 什么是覆盖索引和回表
覆盖索引是指当前查询的数据行中某个字段等于或者包含在索引中，此时只需要返回索引值，不需要回表查询

<br>

## 什么是MVCC？原理是什么？
### 什么是MVCC？
MVCC是MySQL中的多版本并发控制机制，在InnoDB中就是指在已提交可读和可重复读两种事务隔离场景下，select操作会访问数据行的版本控制链的过程
- 包含事务ID和回滚指针，事务ID指代当前执行select操作的事务，而回滚指针指向了undo log中上一个版本的记录
- 不同事务或相同事务对于同一条记录的修改，会在undo log中形成一条串行的版本链
- 读操作只会读取版本号小于等于当前事务ID的数据，而每一次写操作都会创建一个新版本
- 读写操作不会相互堵塞，保证了数据的一致性，提高并发性能；需要维护多个版本，占用大量内存，版本链过长额情况下会产生查询性能问题
- ReadView:
  - 在ReadView内部维护一个事务ID列表，存储已经开始但还没有提交的事务的标识
  - 如果你是已提交读隔离级别，这时候你会重新一个ReadView，那你的活动事务列表中的值就变了，变成了[110]。按照上的说法，你去版本链通过trx_id对比查找到合适的结果就是小明2。
  - 如果你是可重复读隔离级别，这时候你的ReadView还是第一次select时候生成的ReadView,也就是列表的值还是[100]。所以select的结果是小明1。所以第二次select结果和第一次一样，所以叫可重复读！

<br>

## InnoDB锁的类型
### 从同步的数据范围来看分为：
- 表锁
- 行锁：分为乐观锁和悲观锁
### 从是否共享的角度来看：
- 共享锁（行锁，读锁）
- 排他锁（行锁，写锁）
### 意向锁
- 意向共享锁：当一个事务想要给数据行加共享锁时，需要先获取意向共享锁
- 意向排他锁：当一个事务想要给数据行加排他锁时，需要先获取意向排他锁


<br>


## 大数据如何分表
1. 分库：在微服务体系下已经等同于分库
2. 垂直分表：将常用列和不常用列分到不同的表里
3. 水平分表：根据sharing_key进行水平分表，对sharing_key进行hash处理
### 水平分表如何保证id唯一性
- 使用分布式唯一ID生成器，比如雪花算法，在分布式环境下生成唯一ID
> | 1位标志位 | 41位时间戳 | 5位数据中心ID | 5位机器ID | 12位序列号 |
- 每一张分表设置唯一的前缀，入表的数据使用自增ID加上独立前缀作为ID
- 分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用


<br>

## MySQL的主从复制
- binlog日志：负责将主服务器上额二级制数据写入binlog文件中
- IO线程：负责从主服务读取二进制文件并写入副本服务器的中继日志中
- SQL线程：重放中继日志中的SQL语句，实现数据入库
### 同步机制
- 同步复制：所有从库完成同步后，主库才认为已完成
- 半同步复制：有一个从库完成同步后返回ack，主库就认为已经完成

<br>

## 主从读写隔离
主库负责数据写入，从库负责数据读取


<br>

## 最佳左前缀法则
根据最佳左前缀法则，应该根据查询条件的频率和重要性来设计索引，将最常用和最重要的条件放在索引的最左边。这样可以确保查询能够充分利用索引，提高查询的性能和效率。



