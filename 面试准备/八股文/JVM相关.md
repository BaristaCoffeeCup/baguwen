## 内存的分类

- **线程私有**：程序计数器、虚拟机栈、本地方法区
- **线程共享**：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）


## 程序计数器
又名程序计数寄存器（Program Counter Register）, JVM中的PCR并不是传统意义上的物理寄存器，而是用于**存储指向下一条指令的地址，即将要执行的指令代码**。由执行引擎读取下一条指令。

- 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域
- 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致
- 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- **它是唯一一个在 JVM 规范中没有规定任何 ****`OutOfMemoryError`**** 情况的区域**


## 虚拟机栈
### 1. 虚拟机栈的存储单位
栈帧（Stack Frame），线程私有，每个线程有独立的栈，当前线程上每一个正在执行的方法，都有私有的栈帧。栈帧保存方法执行过程中的局部变量，执行结果等数据，参与方法的调用和结果返回。

### 2. 虚拟机栈可能出现的问题
Java 虚拟机规范允许 **Java虚拟机栈的大小是动态的或者是固定不变的**
- 如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 **StackOverflowError** 异常
- 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个**OutOfMemoryError**异常

### 3. 栈的运行原理
- 虚拟机栈通过压栈和出栈来实现方法的调用
- 当前正在调用的方法，其对应的栈帧存放于虚拟机栈的顶层，所有指令仅对当前这一个栈帧处理
- 当前方法调用了另一个方法时，则会创建一个新的栈帧，压栈后放在虚拟栈的顶层
- 方法执行结束（Return）或方法内部抛出异常后，当前栈帧会将执行结果返回给下一个栈帧，JVM会舍弃该栈帧并做出栈操作
- 不同虚拟栈之间的栈帧不可相互引用

### 4. 栈帧的内部结构
- 局部变量表：存储方法参数和定义在方法体内的局部变量
- 操作数栈：保存计算过程中的中间结果，并作为计算过程中变量的临时存储空间（本身是栈，1 + 2 这种表达式依次进栈出栈，完成计算）
- 动态链接：每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。
- 方法返回地址：用来存放调用该方法的 PC 寄存器的值（方法返回后需要重新设置调用者栈帧的PCR的值）


## 本地方法栈
用于管理本地方法的调用，线程私有，允许线程固定或动态扩展大小


## 堆内存

Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。

### 1. 堆内存的分类
- 新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代
- 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
- 元空间（永久代/非堆区）：像一些方法中的操作临时对象等

#### 新生代
年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 **Minor GC**。年轻一代被分为三个部分——伊甸园（**Eden Memory**）和两个幸存区（**Survivor Memory**，被称为from/to或s0/s1），默认比例是`8:1:1`
- 大多数新创建的对象都位于 Eden 内存空间中
- 当 Eden 空间被对象填充时，执行**Minor GC**，并将所有幸存者对象移动到一个幸存者空间中
- Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的
- 经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代

#### 老年代
旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。
大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝

## 方法区/Non-Heap
方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。